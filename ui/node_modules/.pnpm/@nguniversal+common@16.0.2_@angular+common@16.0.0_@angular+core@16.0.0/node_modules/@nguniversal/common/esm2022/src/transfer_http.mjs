/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse, } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule, TransferState, makeStateKey, } from '@angular/core';
import { of as observableOf } from 'rxjs';
import { defaultIfEmpty, first, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
function getHeadersMap(headers) {
    const headersMap = {};
    for (const key of headers.keys()) {
        const values = headers.getAll(key);
        if (values !== null) {
            headersMap[key] = values;
        }
    }
    return headersMap;
}
class TransferHttpCacheInterceptor {
    makeCacheKey(method, url, params, responseType) {
        // make the params encoded same as a url so it's easy to identify
        const encodedParams = params
            .keys()
            .sort()
            .map((k) => `${k}=${params.getAll(k)}`)
            .join('&');
        const key = (method === 'GET' ? 'G.' : 'H.') + responseType + '.' + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(first((isStable) => isStable), defaultIfEmpty(false))
            .subscribe(() => {
            this.isCacheActive = false;
        });
    }
    intercept(req, next) {
        if (!this.isCacheActive || (req.method !== 'GET' && req.method !== 'HEAD')) {
            // Cache is no longer active or method is not HEAD or GET.
            // Pass the request through.
            return next.handle(req);
        }
        const storeKey = this.makeCacheKey(req.method, req.url, req.params, req.responseType);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            const response = this.transferState.get(storeKey, null);
            let body = response?.body;
            switch (response?.responseType) {
                case 'arraybuffer':
                    body = new TextEncoder().encode(response.body).buffer;
                    break;
                case 'blob':
                    body = new Blob([response.body]);
                    break;
            }
            return observableOf(new HttpResponse({
                body,
                headers: new HttpHeaders(response?.headers),
                status: response?.status,
                statusText: response?.statusText,
                url: response?.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            const httpEvent = next.handle(req);
            return httpEvent.pipe(tap((event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                        responseType: req.responseType,
                    });
                }
            }));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheInterceptor, deps: [{ token: i0.ApplicationRef }, { token: i0.TransferState }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheInterceptor }); }
}
export { TransferHttpCacheInterceptor };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ApplicationRef }, { type: i0.TransferState }]; } });
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
class TransferHttpCacheModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheModule, providers: [
            ApplicationRef,
            TransferState,
            TransferHttpCacheInterceptor,
            { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
        ] }); }
}
export { TransferHttpCacheModule };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0-rc.2", ngImport: i0, type: TransferHttpCacheModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        ApplicationRef,
                        TransferState,
                        TransferHttpCacheInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                    ],
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFDTCxpQkFBaUIsRUFHakIsV0FBVyxFQUlYLFlBQVksR0FDYixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFDTCxjQUFjLEVBQ2QsVUFBVSxFQUNWLFFBQVEsRUFFUixhQUFhLEVBQ2IsWUFBWSxHQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQWE1RCxTQUFTLGFBQWEsQ0FBQyxPQUFvQjtJQUN6QyxNQUFNLFVBQVUsR0FBNkIsRUFBRSxDQUFDO0lBQ2hELEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2hDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsSUFBSSxNQUFNLEtBQUssSUFBSSxFQUFFO1lBQ25CLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUM7U0FDMUI7S0FDRjtJQUVELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFFRCxNQUNhLDRCQUE0QjtJQUcvQixZQUFZLENBQ2xCLE1BQWMsRUFDZCxHQUFXLEVBQ1gsTUFBa0IsRUFDbEIsWUFBMEI7UUFFMUIsaUVBQWlFO1FBQ2pFLE1BQU0sYUFBYSxHQUFHLE1BQU07YUFDekIsSUFBSSxFQUFFO2FBQ04sSUFBSSxFQUFFO2FBQ04sR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxN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LElBQUk7d0JBQ2hCLE9BQU8sRUFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQzt3QkFDckMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO3dCQUNwQixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVU7d0JBQzVCLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLEVBQUU7d0JBQ3BCLFlBQVksRUFBRSxHQUFHLENBQUMsWUFBWTtxQkFDL0IsQ0FBQyxDQUFDO2lCQUNKO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztTQUNIO0lBQ0gsQ0FBQzttSEFyRlUsNEJBQTRCO3VIQUE1Qiw0QkFBNEI7O1NBQTVCLDRCQUE0QjtnR0FBNUIsNEJBQTRCO2tCQUR4QyxVQUFVOztBQXlGWDs7O0dBR0c7QUFDSCxNQVFhLHVCQUF1QjttSEFBdkIsdUJBQXVCO29IQUF2Qix1QkFBdUI7b0hBQXZCLHVCQUF1QixhQVB2QjtZQUNULGNBQWM7WUFDZCxhQUFhO1lBQ2IsNEJBQTRCO1lBQzVCLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO1NBQ3ZGOztTQUVVLHVCQUF1QjtnR0FBdkIsdUJBQXVCO2tCQVJuQyxRQUFRO21CQUFDO29CQUNSLFNBQVMsRUFBRTt3QkFDVCxjQUFjO3dCQUNkLGFBQWE7d0JBQ2IsNEJBQTRCO3dCQUM1QixFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtxQkFDdkY7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgSFRUUF9JTlRFUkNFUFRPUlMsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBIZWFkZXJzLFxuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBQYXJhbXMsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwUmVzcG9uc2UsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7XG4gIEFwcGxpY2F0aW9uUmVmLFxuICBJbmplY3RhYmxlLFxuICBOZ01vZHVsZSxcbiAgU3RhdGVLZXksXG4gIFRyYW5zZmVyU3RhdGUsXG4gIG1ha2VTdGF0ZUtleSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlZmF1bHRJZkVtcHR5LCBmaXJzdCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG50eXBlIFJlc3BvbnNlVHlwZSA9IEh0dHBSZXF1ZXN0PHVua25vd24+WydyZXNwb25zZVR5cGUnXTtcblxuaW50ZXJmYWNlIFRyYW5zZmVySHR0cFJlc3BvbnNlIHtcbiAgYm9keTogYW55O1xuICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT47XG4gIHN0YXR1cz86IG51bWJlcjtcbiAgc3RhdHVzVGV4dD86IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICByZXNwb25zZVR5cGU/OiBSZXNwb25zZVR5cGU7XG59XG5cbmZ1bmN0aW9uIGdldEhlYWRlcnNNYXAoaGVhZGVyczogSHR0cEhlYWRlcnMpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4ge1xuICBjb25zdCBoZWFkZXJzTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgaGVhZGVycy5rZXlzKCkpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBoZWFkZXJzLmdldEFsbChrZXkpO1xuICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgIGhlYWRlcnNNYXBba2V5XSA9IHZhbHVlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGVhZGVyc01hcDtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBwcml2YXRlIGlzQ2FjaGVBY3RpdmUgPSB0cnVlO1xuXG4gIHByaXZhdGUgbWFrZUNhY2hlS2V5KFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIHVybDogc3RyaW5nLFxuICAgIHBhcmFtczogSHR0cFBhcmFtcyxcbiAgICByZXNwb25zZVR5cGU6IFJlc3BvbnNlVHlwZSxcbiAgKTogU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+IHtcbiAgICAvLyBtYWtlIHRoZSBwYXJhbXMgZW5jb2RlZCBzYW1lIGFzIGEgdXJsIHNvIGl0J3MgZWFzeSB0byBpZGVudGlmeVxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBwYXJhbXNcbiAgICAgIC5rZXlzKClcbiAgICAgIC5zb3J0KClcbiAgICAgIC5tYXAoKGspID0+IGAke2t9PSR7cGFyYW1zLmdldEFsbChrKX1gKVxuICAgICAgLmpvaW4oJyYnKTtcblxuICAgIGNvbnN0IGtleSA9IChtZXRob2QgPT09ICdHRVQnID8gJ0cuJyA6ICdILicpICsgcmVzcG9uc2VUeXBlICsgJy4nICsgdXJsICsgJz8nICsgZW5jb2RlZFBhcmFtcztcblxuICAgIHJldHVybiBtYWtlU3RhdGVLZXk8VHJhbnNmZXJIdHRwUmVzcG9uc2U+KGtleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhcHBSZWY6IEFwcGxpY2F0aW9uUmVmLCBwcml2YXRlIHRyYW5zZmVyU3RhdGU6IFRyYW5zZmVyU3RhdGUpIHtcbiAgICAvLyBTdG9wIHVzaW5nIHRoZSBjYWNoZSBpZiB0aGUgYXBwbGljYXRpb24gaGFzIHN0YWJpbGl6ZWQsIGluZGljYXRpbmcgaW5pdGlhbCByZW5kZXJpbmcgaXNcbiAgICAvLyBjb21wbGV0ZS5cbiAgICBhcHBSZWYuaXNTdGFibGVcbiAgICAgIC5waXBlKFxuICAgICAgICBmaXJzdCgoaXNTdGFibGUpID0+IGlzU3RhYmxlKSxcbiAgICAgICAgZGVmYXVsdElmRW1wdHkoZmFsc2UpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDYWNoZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgfSk7XG4gIH1cblxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBpZiAoIXRoaXMuaXNDYWNoZUFjdGl2ZSB8fCAocmVxLm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxLm1ldGhvZCAhPT0gJ0hFQUQnKSkge1xuICAgICAgLy8gQ2FjaGUgaXMgbm8gbG9uZ2VyIGFjdGl2ZSBvciBtZXRob2QgaXMgbm90IEhFQUQgb3IgR0VULlxuICAgICAgLy8gUGFzcyB0aGUgcmVxdWVzdCB0aHJvdWdoLlxuICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVLZXkgPSB0aGlzLm1ha2VDYWNoZUtleShyZXEubWV0aG9kLCByZXEudXJsLCByZXEucGFyYW1zLCByZXEucmVzcG9uc2VUeXBlKTtcblxuICAgIGlmICh0aGlzLnRyYW5zZmVyU3RhdGUuaGFzS2V5KHN0b3JlS2V5KSkge1xuICAgICAgLy8gUmVxdWVzdCBmb3VuZCBpbiBjYWNoZS4gUmVzcG9uZCB1c2luZyBpdC5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy50cmFuc2ZlclN0YXRlLmdldChzdG9yZUtleSwgbnVsbCk7XG4gICAgICBsZXQgYm9keTogQXJyYXlCdWZmZXIgfCBCbG9iIHwgc3RyaW5nIHwgdW5kZWZpbmVkID0gcmVzcG9uc2U/LmJvZHk7XG5cbiAgICAgIHN3aXRjaCAocmVzcG9uc2U/LnJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgYm9keSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyZXNwb25zZS5ib2R5KS5idWZmZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgIGJvZHkgPSBuZXcgQmxvYihbcmVzcG9uc2UuYm9keV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKFxuICAgICAgICBuZXcgSHR0cFJlc3BvbnNlPGFueT4oe1xuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHJlc3BvbnNlPy5oZWFkZXJzKSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlPy5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2U/LnN0YXR1c1RleHQsXG4gICAgICAgICAgdXJsOiByZXNwb25zZT8udXJsLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG5cbiAgICAgIHJldHVybiBodHRwRXZlbnQucGlwZShcbiAgICAgICAgdGFwKChldmVudDogSHR0cEV2ZW50PHVua25vd24+KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVyU3RhdGUuc2V0PFRyYW5zZmVySHR0cFJlc3BvbnNlPihzdG9yZUtleSwge1xuICAgICAgICAgICAgICBib2R5OiBldmVudC5ib2R5LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzTWFwKGV2ZW50LmhlYWRlcnMpLFxuICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZXZlbnQuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgdXJsOiBldmVudC51cmwgfHwgJycsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogcmVxLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIE5nTW9kdWxlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgU2VydmVyVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGVgIHRvIHRyYW5zZmVyIGNhY2hlZCBIVFRQXG4gKiBjYWxscyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCBhcHBsaWNhdGlvbi5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbXG4gICAgQXBwbGljYXRpb25SZWYsXG4gICAgVHJhbnNmZXJTdGF0ZSxcbiAgICBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLFxuICAgIHsgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUV4aXN0aW5nOiBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZSB7fVxuIl19